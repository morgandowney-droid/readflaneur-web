import { NextResponse } from 'next/server';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { render } from '@react-email/components';
import { SundayEditionTemplate, SundayEditionContent } from '@/lib/email/templates/SundayEditionTemplate';
import { sendEmail } from '@/lib/email';
import { resolveRecipients } from '@/lib/email/scheduler';
import { resolveSundayAd } from '@/lib/email/sunday-ad-resolver';

/**
 * Send "The Sunday Edition" weekly email to subscribers.
 *
 * Runs hourly on Sundays, sending at 7 AM local time for each recipient.
 * Uses the structured weekly_briefs data generated by sync-weekly-brief.
 *
 * Schedule: 0 * * * 0 (every hour on Sundays)
 */

export const runtime = 'nodejs';
export const maxDuration = 300;

const MAX_EMAILS_PER_RUN = 80;
const DELAY_BETWEEN_SENDS_MS = 500;

export async function GET(request: Request) {
  const functionStart = Date.now();

  const authHeader = request.headers.get('authorization');
  const cronSecret = process.env.CRON_SECRET;

  const isAuthorized =
    authHeader === `Bearer ${cronSecret}` ||
    request.headers.get('x-vercel-cron') === '1' ||
    process.env.NODE_ENV === 'development';

  if (!isAuthorized) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const url = new URL(request.url);
  const testEmail = url.searchParams.get('test');
  const force = url.searchParams.get('force') === 'true';
  const dry = url.searchParams.get('dry') === 'true';

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  const startedAt = new Date().toISOString();
  const today = new Date();
  const weekDate = today.toISOString().split('T')[0];

  // Only send on Sundays (unless test/force mode)
  if (!testEmail && !force && today.getUTCDay() !== 0) {
    return NextResponse.json({
      success: true,
      message: 'Not Sunday, skipping',
      timestamp: new Date().toISOString(),
    });
  }

  const results = {
    recipients_found: 0,
    emails_sent: 0,
    emails_failed: 0,
    emails_skipped: 0,
    errors: [] as string[],
    dry_run: dry,
    test_mode: !!testEmail,
  };

  try {
    // Resolve recipients (7 AM local time, same as daily brief)
    let recipients;
    if (testEmail) {
      recipients = await buildTestRecipient(supabase, testEmail);
    } else {
      recipients = await resolveRecipients(supabase, 7);
    }

    results.recipients_found = recipients.length;

    if (recipients.length === 0) {
      return NextResponse.json({
        success: true,
        ...results,
        message: 'No recipients at target hour',
      });
    }

    // Dedup: skip anyone who already got a Sunday edition this week
    const { data: alreadySent } = await supabase
      .from('weekly_brief_sends')
      .select('recipient_id')
      .eq('week_date', weekDate);

    const sentSet = new Set((alreadySent || []).map(s => s.recipient_id));

    const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://readflaneur.com';

    let emailsSent = 0;

    for (const recipient of recipients) {
      if (emailsSent >= MAX_EMAILS_PER_RUN) break;

      if (!testEmail && sentSet.has(recipient.id)) {
        results.emails_skipped++;
        continue;
      }

      // Check if recipient has opted out of Sunday Edition
      if (!testEmail) {
        const table = recipient.source === 'newsletter' ? 'newsletter_subscribers' : 'profiles';
        const { data: pref } = await supabase
          .from(table)
          .select('sunday_edition_enabled')
          .eq('id', recipient.id)
          .single();
        if (pref && pref.sunday_edition_enabled === false) {
          results.emails_skipped++;
          continue;
        }
      }

      // Get the primary neighborhood's weekly brief
      const primaryId = recipient.primaryNeighborhoodId || recipient.subscribedNeighborhoodIds[0];
      if (!primaryId) {
        results.emails_skipped++;
        continue;
      }

      // In test mode, also check yesterday's date as fallback (sync may have run the day before)
      let brief;
      const { data: todayBrief } = await supabase
        .from('weekly_briefs')
        .select('*, neighborhoods(name, city), articles(slug)')
        .eq('neighborhood_id', primaryId)
        .eq('week_date', weekDate)
        .single();

      brief = todayBrief;

      if (!brief && testEmail) {
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayDate = yesterday.toISOString().split('T')[0];
        const { data: fallbackBrief } = await supabase
          .from('weekly_briefs')
          .select('*, neighborhoods(name, city), articles(slug)')
          .eq('neighborhood_id', primaryId)
          .eq('week_date', yesterdayDate)
          .single();
        brief = fallbackBrief;
      }

      if (!brief) {
        results.emails_skipped++;
        continue;
      }

      const hood = brief.neighborhoods as unknown as { name: string; city: string };
      const articleSlug = (brief.articles as unknown as { slug: string } | null)?.slug;

      // Format the date nicely
      const dateStr = today.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        timeZone: recipient.timezone || 'America/New_York',
      });

      // Build article URL for "Read the full edition" link
      let articleUrl: string | null = null;
      if (articleSlug) {
        const neighborhoodSlug = primaryId.split('-').slice(1).join('-');
        const citySlug = hood.city.toLowerCase().replace(/\s+/g, '-');
        articleUrl = `${appUrl}/${citySlug}/${neighborhoodSlug}/${articleSlug}?ref=sunday-edition`;
      }

      const emailContent: SundayEditionContent = {
        neighborhoodName: hood.name,
        cityName: hood.city,
        date: dateStr,
        rearviewNarrative: brief.rearview_narrative || '',
        rearviewStories: (brief.rearview_stories || []) as SundayEditionContent['rearviewStories'],
        horizonEvents: (brief.horizon_events || []) as SundayEditionContent['horizonEvents'],
        dataPoint: (() => {
          const dp = (brief.data_point || {
            type: 'real_estate',
            label: 'The Market',
            value: 'Data unavailable this week',
            context: '',
          }) as SundayEditionContent['dataPoint'];
          // Fix legacy label: environment type must always show "The Temperature"
          if (dp.type === 'environment') {
            dp.label = 'The Temperature';
          }
          return dp;
        })(),
        holidaySection: brief.holiday_section || null,
        imageUrl: null,
        articleUrl,
        unsubscribeUrl: `${appUrl}/api/email/unsubscribe?token=${recipient.unsubscribeToken}`,
        preferencesUrl: `${appUrl}/email/preferences?token=${recipient.unsubscribeToken}`,
      };

      // Resolve sponsor ad for this neighborhood
      const sundayAd = await resolveSundayAd(supabase, primaryId);
      emailContent.sponsorAd = {
        sponsorLabel: sundayAd.sponsorLabel,
        imageUrl: sundayAd.imageUrl,
        headline: sundayAd.headline,
        body: sundayAd.body,
        clickUrl: sundayAd.clickUrl,
      };

      if (dry) {
        results.emails_sent++;
        emailsSent++;
        continue;
      }

      try {
        const html = await render(SundayEditionTemplate(emailContent));
        const subject = `The Sunday Edition: ${hood.name}`;
        const from = process.env.EMAIL_FROM || 'Flaneur <hello@readflaneur.com>';

        const sent = await sendEmail({
          from,
          to: recipient.email,
          subject,
          html,
        });

        if (sent) {
          // Track the send
          await supabase.from('weekly_brief_sends').insert({
            recipient_id: recipient.id,
            recipient_email: recipient.email,
            neighborhood_id: primaryId,
            week_date: weekDate,
          }).then(null, () => {});

          // Track ad impression
          if (sundayAd.adId) {
            const { error: rpcErr } = await supabase.rpc('increment_ad_impressions', { ad_id: sundayAd.adId });
            if (rpcErr) {
              // Fallback: select then update
              const { data: adRow } = await supabase.from('ads').select('impressions').eq('id', sundayAd.adId).single();
              if (adRow) {
                await supabase.from('ads').update({ impressions: (adRow.impressions || 0) + 1 }).eq('id', sundayAd.adId).then(null, () => {});
              }
            }
          }

          results.emails_sent++;
          emailsSent++;
        } else {
          results.emails_failed++;
          results.errors.push(`Failed to send to ${recipient.email}`);
        }
      } catch (err) {
        results.emails_failed++;
        results.errors.push(`${recipient.email}: ${err instanceof Error ? err.message : String(err)}`);
      }

      await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_SENDS_MS));
    }
  } finally {
    if (!testEmail) {
      await supabase.from('cron_executions').insert({
        job_name: 'send-sunday-edition',
        started_at: startedAt,
        completed_at: new Date().toISOString(),
        success: results.emails_sent > 0 || results.recipients_found === 0,
        articles_created: results.emails_sent,
        errors: results.errors.length > 0 ? results.errors : null,
        response_data: results,
      }).then(null, (e: unknown) => console.error('Failed to log cron execution:', e));
    }
  }

  return NextResponse.json({
    success: true,
    ...results,
    elapsed_ms: Date.now() - functionStart,
    timestamp: new Date().toISOString(),
  });
}

/**
 * Build a test recipient from an email address.
 */
async function buildTestRecipient(supabase: SupabaseClient, email: string) {
  // Try profile first
  const { data: profile } = await supabase
    .from('profiles')
    .select('id, email, primary_timezone, primary_city, email_unsubscribe_token')
    .eq('email', email)
    .single();

  if (profile) {
    const { data: prefs } = await supabase
      .from('user_neighborhood_preferences')
      .select('neighborhood_id')
      .eq('user_id', profile.id);

    const neighborhoodIds = (prefs || []).map(p => p.neighborhood_id);
    return [{
      id: profile.id,
      email: profile.email,
      source: 'profile' as const,
      timezone: profile.primary_timezone || 'America/New_York',
      primaryNeighborhoodId: neighborhoodIds[0] || null,
      subscribedNeighborhoodIds: neighborhoodIds,
      unsubscribeToken: profile.email_unsubscribe_token || profile.id,
      pausedTopics: [],
    }];
  }

  // Try newsletter subscriber
  const { data: sub } = await supabase
    .from('newsletter_subscribers')
    .select('id, email, timezone, neighborhood_ids, unsubscribe_token')
    .eq('email', email)
    .single();

  if (sub) {
    const ids = sub.neighborhood_ids || [];
    return [{
      id: sub.id,
      email: sub.email,
      source: 'newsletter' as const,
      timezone: sub.timezone || 'America/New_York',
      primaryNeighborhoodId: ids[0] || null,
      subscribedNeighborhoodIds: ids,
      unsubscribeToken: sub.unsubscribe_token || sub.id,
      pausedTopics: [],
    }];
  }

  return [];
}


