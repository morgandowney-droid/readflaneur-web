import { NextResponse } from 'next/server';
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { render } from '@react-email/components';
import { SundayEditionTemplate, SundayEditionContent } from '@/lib/email/templates/SundayEditionTemplate';
import { sendEmail } from '@/lib/email';
import { checkDailyEmailLimit } from '@/lib/email/daily-email-limit';
import { resolveRecipients } from '@/lib/email/scheduler';
import { resolveSundayAd } from '@/lib/email/sunday-ad-resolver';
import { fetchWeather } from '@/lib/email/weather';

/**
 * Send "The Sunday Edition" weekly email to subscribers.
 *
 * Runs hourly on Sundays, sending at 7 AM local time for each recipient.
 * Uses the structured weekly_briefs data generated by sync-weekly-brief.
 *
 * Schedule: 0 * * * 0 (every hour on Sundays)
 */

export const runtime = 'nodejs';
export const maxDuration = 300;

const MAX_EMAILS_PER_RUN = 80;
const DELAY_BETWEEN_SENDS_MS = 500;

export async function GET(request: Request) {
  const functionStart = Date.now();

  const authHeader = request.headers.get('authorization');
  const cronSecret = process.env.CRON_SECRET;

  const isAuthorized =
    authHeader === `Bearer ${cronSecret}` ||
    request.headers.get('x-vercel-cron') === '1' ||
    process.env.NODE_ENV === 'development';

  if (!isAuthorized) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const url = new URL(request.url);
  const testEmail = url.searchParams.get('test');
  const force = url.searchParams.get('force') === 'true';
  const dry = url.searchParams.get('dry') === 'true';

  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  const startedAt = new Date().toISOString();
  const today = new Date();
  const weekDate = today.toISOString().split('T')[0];

  // Only send on Sundays (unless test/force mode)
  if (!testEmail && !force && today.getUTCDay() !== 0) {
    return NextResponse.json({
      success: true,
      message: 'Not Sunday, skipping',
      timestamp: new Date().toISOString(),
    });
  }

  const results = {
    recipients_found: 0,
    emails_sent: 0,
    emails_failed: 0,
    emails_skipped: 0,
    errors: [] as string[],
    dry_run: dry,
    test_mode: !!testEmail,
  };

  try {
    // Resolve recipients (7 AM local time, same as daily brief)
    let recipients;
    if (testEmail) {
      recipients = await buildTestRecipient(supabase, testEmail);
    } else {
      recipients = await resolveRecipients(supabase, 7);
    }

    results.recipients_found = recipients.length;

    if (recipients.length === 0) {
      return NextResponse.json({
        success: true,
        ...results,
        message: 'No recipients at target hour',
      });
    }

    // Dedup: skip anyone who already got a Sunday edition for their primary neighborhood this week
    const { data: alreadySent } = await supabase
      .from('weekly_brief_sends')
      .select('recipient_id, neighborhood_id')
      .eq('week_date', weekDate);

    const sentSet = new Set(
      (alreadySent || []).map(s => `${s.recipient_id}:${s.neighborhood_id}`)
    );

    // Batch fetch all neighborhood names for secondary neighborhood links
    const allSubscribedIds = new Set<string>();
    for (const r of recipients) {
      for (const nid of r.subscribedNeighborhoodIds) {
        allSubscribedIds.add(nid);
      }
    }
    const neighborhoodNameMap = new Map<string, { name: string; city: string }>();
    if (allSubscribedIds.size > 0) {
      const { data: allHoods } = await supabase
        .from('neighborhoods')
        .select('id, name, city')
        .in('id', Array.from(allSubscribedIds));
      for (const h of (allHoods || [])) {
        neighborhoodNameMap.set(h.id, { name: h.name, city: h.city });
      }
    }

    const appUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://readflaneur.com';

    let emailsSent = 0;

    for (const recipient of recipients) {
      if (emailsSent >= MAX_EMAILS_PER_RUN) break;

      // Get primary neighborhood ID early for dedup check
      const primaryId = recipient.primaryNeighborhoodId || recipient.subscribedNeighborhoodIds[0];

      if (!testEmail && primaryId && sentSet.has(`${recipient.id}:${primaryId}`)) {
        results.emails_skipped++;
        results.errors.push(`skip:dedup:${recipient.id}:${primaryId}`);
        continue;
      }

      // Check if recipient has opted out of Sunday Edition
      if (!testEmail) {
        const table = recipient.source === 'newsletter' ? 'newsletter_subscribers' : 'profiles';
        const { data: pref } = await supabase
          .from(table)
          .select('sunday_edition_enabled')
          .eq('id', recipient.id)
          .single();
        if (pref && pref.sunday_edition_enabled === false) {
          results.emails_skipped++;
          results.errors.push(`skip:opted_out:${recipient.id}`);
          continue;
        }
      }

      // Get the primary neighborhood's weekly brief
      if (!primaryId) {
        results.emails_skipped++;
        results.errors.push(`skip:no_primary_id:${recipient.id}`);
        continue;
      }

      // In test mode, also check yesterday's date and most recent brief as fallback
      let brief;
      const { data: todayBrief } = await supabase
        .from('weekly_briefs')
        .select('*, neighborhoods(name, city, latitude, longitude, country), articles(slug)')
        .eq('neighborhood_id', primaryId)
        .eq('week_date', weekDate)
        .single();

      brief = todayBrief;

      if (!brief && testEmail) {
        // Try the most recent brief for this neighborhood (regardless of date)
        const { data: recentBriefs } = await supabase
          .from('weekly_briefs')
          .select('*, neighborhoods(name, city, latitude, longitude, country), articles(slug)')
          .eq('neighborhood_id', primaryId)
          .order('week_date', { ascending: false })
          .limit(1);
        brief = recentBriefs?.[0] || null;
      }

      if (!brief) {
        results.emails_skipped++;
        results.errors.push(`skip:no_brief:${primaryId}:${weekDate}`);
        continue;
      }

      const hood = brief.neighborhoods as unknown as { name: string; city: string; latitude: number | null; longitude: number | null; country: string | null };
      const articleSlug = (brief.articles as unknown as { slug: string } | null)?.slug;

      // Format the date nicely
      const dateStr = today.toLocaleDateString('en-US', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        timeZone: recipient.timezone || 'America/New_York',
      });

      // Build article URL for "Read the full edition" link
      let articleUrl: string | null = null;
      if (articleSlug) {
        const neighborhoodSlug = primaryId.split('-').slice(1).join('-');
        const citySlug = hood.city.toLowerCase().replace(/\s+/g, '-');
        articleUrl = `${appUrl}/${citySlug}/${neighborhoodSlug}/${articleSlug}?ref=sunday-edition`;
      }

      // Fetch Look Ahead article URL for this neighborhood
      let lookAheadUrl: string | null = null;
      try {
        const cutoff = new Date();
        cutoff.setHours(cutoff.getHours() - 48);
        const { data: lookAheadArticles } = await supabase
          .from('articles')
          .select('slug')
          .eq('neighborhood_id', primaryId)
          .eq('status', 'published')
          .eq('article_type', 'look_ahead')
          .gte('published_at', cutoff.toISOString())
          .order('published_at', { ascending: false })
          .limit(1);
        if (lookAheadArticles && lookAheadArticles.length > 0) {
          const neighborhoodSlugForUrl = primaryId.split('-').slice(1).join('-');
          const citySlugForUrl = hood.city.toLowerCase().replace(/\s+/g, '-');
          lookAheadUrl = `${appUrl}/${citySlugForUrl}/${neighborhoodSlugForUrl}/${lookAheadArticles[0].slug}`;
        }
      } catch {}

      const emailContent: SundayEditionContent = {
        neighborhoodName: hood.name,
        cityName: hood.city,
        date: dateStr,
        rearviewNarrative: brief.rearview_narrative || '',
        rearviewStories: (brief.rearview_stories || []) as SundayEditionContent['rearviewStories'],
        horizonEvents: (brief.horizon_events || []) as SundayEditionContent['horizonEvents'],
        dataPoint: await (async () => {
          const dp = (brief.data_point || {
            type: 'real_estate',
            label: 'The Market',
            value: 'Data unavailable this week',
            context: '',
          }) as SundayEditionContent['dataPoint'];
          // Fix legacy briefs that stored AQI instead of temperature
          if (dp.type === 'environment' && /AQI/i.test(dp.value)) {
            if (hood.latitude && hood.longitude) {
              const weather = await fetchWeather(
                hood.latitude, hood.longitude,
                recipient.timezone || 'America/New_York',
                hood.country || 'USA'
              );
              if (weather) {
                const temp = weather.useFahrenheit
                  ? `${weather.temperatureF}°F`
                  : `${weather.temperatureC}°C`;
                dp.value = temp;
                dp.context = weather.description;
              }
            }
          }
          return dp;
        })(),
        holidaySection: brief.holiday_section || null,
        imageUrl: null,
        articleUrl,
        unsubscribeUrl: `${appUrl}/api/email/unsubscribe?token=${recipient.unsubscribeToken}`,
        preferencesUrl: `${appUrl}/email/preferences?token=${recipient.unsubscribeToken}`,
        referralUrl: recipient.referralCode
          ? `${appUrl}/invite?ref=${recipient.referralCode}`
          : undefined,
        secondaryNeighborhoods: (recipient.subscribedNeighborhoodIds as string[])
          .filter((nid: string) => nid !== primaryId)
          .map((nid: string) => {
            const info = neighborhoodNameMap.get(nid);
            return info ? { id: nid, name: info.name, cityName: info.city } : null;
          })
          .filter((x: { id: string; name: string; cityName: string } | null): x is { id: string; name: string; cityName: string } => x !== null),
        requestBaseUrl: `${appUrl}/api/email/sunday-edition-request`,
        requestToken: recipient.unsubscribeToken,
        lookAheadUrl,
      };

      // Resolve sponsor ad for this neighborhood
      const sundayAd = await resolveSundayAd(supabase, primaryId);
      emailContent.sponsorAd = {
        sponsorLabel: sundayAd.sponsorLabel,
        imageUrl: sundayAd.imageUrl,
        headline: sundayAd.headline,
        body: sundayAd.body,
        clickUrl: sundayAd.clickUrl,
      };

      if (dry) {
        results.emails_sent++;
        emailsSent++;
        continue;
      }

      try {
        // Check global daily email limit (5/day across all email types)
        const limit = await checkDailyEmailLimit(supabase, recipient.id);
        if (!limit.allowed) {
          console.log(`Daily email limit reached for ${recipient.email} (${limit.count} sent today), skipping Sunday Edition`);
          continue;
        }

        const html = await render(SundayEditionTemplate(emailContent));
        const subject = `The Sunday Edition: ${hood.name}`;
        const from = process.env.EMAIL_FROM || 'Flaneur <hello@readflaneur.com>';

        const sent = await sendEmail({
          from,
          to: recipient.email,
          subject,
          html,
        });

        if (sent) {
          // Track the send
          await supabase.from('weekly_brief_sends').insert({
            recipient_id: recipient.id,
            recipient_email: recipient.email,
            neighborhood_id: primaryId,
            week_date: weekDate,
          }).then(null, () => {});

          // Track ad impression
          if (sundayAd.adId) {
            const { error: rpcErr } = await supabase.rpc('increment_ad_impressions', { ad_id: sundayAd.adId });
            if (rpcErr) {
              // Fallback: select then update
              const { data: adRow } = await supabase.from('ads').select('impressions').eq('id', sundayAd.adId).single();
              if (adRow) {
                await supabase.from('ads').update({ impressions: (adRow.impressions || 0) + 1 }).eq('id', sundayAd.adId).then(null, () => {});
              }
            }
          }

          results.emails_sent++;
          emailsSent++;
        } else {
          results.emails_failed++;
          results.errors.push(`Failed to send to ${recipient.email}`);
        }
      } catch (err) {
        results.emails_failed++;
        results.errors.push(`${recipient.email}: ${err instanceof Error ? err.message : String(err)}`);
      }

      await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_SENDS_MS));
    }
  } finally {
    if (!testEmail) {
      await supabase.from('cron_executions').insert({
        job_name: 'send-sunday-edition',
        started_at: startedAt,
        completed_at: new Date().toISOString(),
        success: results.emails_sent > 0 || results.recipients_found === 0,
        articles_created: results.emails_sent,
        errors: results.errors.length > 0 ? results.errors : null,
        response_data: results,
      }).then(null, (e: unknown) => console.error('Failed to log cron execution:', e));
    }
  }

  return NextResponse.json({
    success: true,
    ...results,
    elapsed_ms: Date.now() - functionStart,
    timestamp: new Date().toISOString(),
  });
}

/**
 * Build a test recipient from an email address.
 */
async function buildTestRecipient(supabase: SupabaseClient, email: string) {
  // Try profile first
  const { data: profile } = await supabase
    .from('profiles')
    .select('id, email, primary_timezone, primary_city, email_unsubscribe_token, referral_code')
    .eq('email', email)
    .single();

  if (profile) {
    const { data: prefs } = await supabase
      .from('user_neighborhood_preferences')
      .select('neighborhood_id')
      .eq('user_id', profile.id);

    const neighborhoodIds = (prefs || []).map(p => p.neighborhood_id);
    return [{
      id: profile.id,
      email: profile.email,
      source: 'profile' as const,
      timezone: profile.primary_timezone || 'America/New_York',
      primaryNeighborhoodId: neighborhoodIds[0] || null,
      subscribedNeighborhoodIds: neighborhoodIds,
      unsubscribeToken: profile.email_unsubscribe_token || profile.id,
      pausedTopics: [],
      referralCode: profile.referral_code || undefined,
    }];
  }

  // Try newsletter subscriber
  const { data: sub } = await supabase
    .from('newsletter_subscribers')
    .select('id, email, timezone, neighborhood_ids, unsubscribe_token, referral_code')
    .eq('email', email)
    .single();

  if (sub) {
    const ids = sub.neighborhood_ids || [];
    return [{
      id: sub.id,
      email: sub.email,
      source: 'newsletter' as const,
      timezone: sub.timezone || 'America/New_York',
      primaryNeighborhoodId: ids[0] || null,
      subscribedNeighborhoodIds: ids,
      unsubscribeToken: sub.unsubscribe_token || sub.id,
      pausedTopics: [],
      referralCode: sub.referral_code || undefined,
    }];
  }

  return [];
}


